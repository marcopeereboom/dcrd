// Copyright (c) 2016-2019 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package ticketdb

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"io/ioutil"
	"os"
	"reflect"
	"testing"

	"github.com/davecgh/go-spew/spew"
	"github.com/decred/dcrd/blockchain/stake/v2/internal/dbnamespace"
	"github.com/decred/dcrd/chaincfg/chainhash"
	"github.com/decred/dcrd/chaincfg/v2"
	"github.com/decred/dcrd/database/v2"
)

const (
	defaultValues = "64000000000000000500000000000000010000000000000002000000000000000300000000000000fdfffffffffffffffeffffffffffffff"

	defaultEmptyValues = "640000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"

	tooManyValues = "6400000000000000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
)

var (
	values []byte
	empty  []byte
	many   []byte
)

func init() {
	var err error
	values, err = hex.DecodeString(defaultValues)
	if err != nil {
		panic(err)
	}
	empty, err = hex.DecodeString(defaultEmptyValues)
	if err != nil {
		panic(err)
	}
	many, err = hex.DecodeString(tooManyValues)
	if err != nil {
		panic(err)
	}
}

func TestSerializeTreasuryState(t *testing.T) {
	tests := []struct {
		name       string
		state      dbnamespace.TreasuryState
		serialized error
		expected   []byte
	}{
		{
			name: "equal",
			state: dbnamespace.TreasuryState{
				Balance: 100,
				Values:  []int64{1, 2, 3, -3, -2},
			},
			serialized: nil,
			expected:   values,
		},
		{
			name: "just enough",
			state: dbnamespace.TreasuryState{
				Balance: 100,
				Values:  make([]int64, dbnamespace.TreasuryMaxEntriesPerBlock),
			},
			serialized: nil,
			expected:   empty,
		},
		{
			name: "negative",
			state: dbnamespace.TreasuryState{
				Balance: -100,
				Values:  []int64{1, 2, 3, -3, -2},
			},
			serialized: DBError{ErrorCode: ErrTreasurySerialization},
		},
		{
			name: "too many",
			state: dbnamespace.TreasuryState{
				Balance: 100,
				Values:  make([]int64, dbnamespace.TreasuryMaxEntriesPerBlock+1),
			},
			serialized: DBError{ErrorCode: ErrTreasurySerialization},
		},
	}

	for i, test := range tests {
		b, err := serializeTreasuryState(test.state)
		t.Logf("%v %v %T %v", i, test.name, err, err)
		if err != nil && test.serialized != nil {
			e, ok := err.(DBError)
			if !ok {
				t.Fatalf("%v %v (serialized): unexpected "+
					"error %T %v", i, test.name, err, err)
			}
			if e.ErrorCode == ErrTreasurySerialization {
				continue
			}
			t.Fatalf("%v %v (serialized): got %v expected %v",
				i, test.name, err, test.serialized)
		}
		if !bytes.Equal(test.expected, b) {
			t.Fatalf("%v %v (serialized): got %x expected %x",
				i, test.name, b, test.expected)
		}
		tso, err := deserializeTreasuryState(b)
		if err != nil {
			t.Fatalf("%v %v (deserialized): %v",
				i, test.name, err)
		}
		if !reflect.DeepEqual(test.state, *tso) {
			t.Fatalf("%v %v (equal): got %v expected %v",
				i, test.name, *tso, test.state)
		}
	}
}

func TestDeserializeTreasuryState(t *testing.T) {
	tests := []struct {
		name         string
		state        []byte
		deserialized error
		expected     dbnamespace.TreasuryState
	}{
		{
			name:         "equal",
			state:        values,
			deserialized: nil,
			expected: dbnamespace.TreasuryState{
				Balance: 100,
				Values:  []int64{1, 2, 3, -3, -2},
			},
		},
		{
			name:         "empty",
			state:        nil,
			deserialized: DBError{ErrorCode: ErrTreasuryDeserialization},
		},
		{
			name:         "short",
			state:        values[0 : len(values)/2],
			deserialized: DBError{ErrorCode: ErrTreasuryDeserialization},
		},
		{
			name:         "one byte short",
			state:        values[0 : len(values)-1],
			deserialized: DBError{ErrorCode: ErrTreasuryDeserialization},
		},
		{
			name:         "too many",
			state:        many,
			deserialized: DBError{ErrorCode: ErrTreasuryDeserialization},
		},
	}

	for i, test := range tests {
		tso, err := deserializeTreasuryState(test.state)
		t.Logf("%v %v %T %v", i, test.name, err, err)
		if err != nil && test.deserialized != nil {
			e, ok := err.(DBError)
			if !ok {
				t.Fatalf("%v %v (deserialized): unexpected "+
					"error %T %v", i, test.name, err, err)
			}
			if e.ErrorCode == ErrTreasuryDeserialization {
				continue
			}
			t.Fatalf("%v %v (deserialized): got %v expected %v",
				i, test.name, err, test.deserialized)
		}
		b, err := serializeTreasuryState(test.expected)
		if err != nil {
			t.Fatalf("%v %v (serialized): %v", i, test.name, err)
		}
		if !bytes.Equal(test.state, b) {
			t.Fatalf("%v %v (serialized): got %x expected %x",
				i, test.name, b, test.expected)
		}
		if !reflect.DeepEqual(*tso, test.expected) {
			t.Fatalf("%v %v (equal): got %v expected %v",
				i, test.name, *tso, test.expected)
		}
	}
}

// TestTreasuryDatabase tests treasury database functionality.
func TestTreasuryDatabase(t *testing.T) {
	// Create a new database to store treasury state.
	dbName := "ffldb_treasurydb_test"
	dbPath, err := ioutil.TempDir("", dbName)
	if err != nil {
		t.Fatalf("unable to create treasury db path: %v", err)
	}
	defer os.RemoveAll(dbPath)
	net := chaincfg.RegNetParams().Net
	testDb, err := database.Create(testDbType, dbPath, net)
	if err != nil {
		t.Fatalf("error creating treasury db: %v", err)
	}
	defer testDb.Close()

	// Initialize the database, then try to read the version.
	err = testDb.Update(DbCreate)
	if err != nil {
		t.Fatalf("%v", err.Error())
	}

	var dbi *DatabaseInfo
	err = testDb.View(func(dbTx database.Tx) error {
		dbi, err = DbFetchDatabaseInfo(dbTx)
		return err
	})
	if err != nil {
		t.Fatalf("%v", err.Error())
	}
	if dbi.Version != currentDatabaseVersion {
		t.Fatalf("bad version after reading from DB; want %v, got %v",
			currentDatabaseVersion, dbi.Version)
	}

	// Write maxTreasuryState records out.
	maxTreasuryState := uint64(1024)
	for i := uint64(0); i < maxTreasuryState; i++ {
		// Create synthetic treasury state
		ts := dbnamespace.TreasuryState{
			Balance: int64(i),
			Values:  []int64{int64(i), -int64(i)},
		}

		// Create hash of counter.
		b := make([]byte, 16)
		binary.LittleEndian.PutUint64(b[0:], i)
		hash := chainhash.HashH(b)

		err = testDb.Update(func(dbTx database.Tx) error {
			return DbPutTreasury(dbTx, hash, ts)
		})
		if err != nil {
			t.Fatalf("%v", err.Error())
		}
	}

	// Pull records back out.
	for i := uint64(0); i < maxTreasuryState; i++ {
		// Create synthetic treasury state
		ts := dbnamespace.TreasuryState{
			Balance: int64(i),
			Values:  []int64{int64(i), -int64(i)},
		}

		// Create hash of counter.
		b := make([]byte, 16)
		binary.LittleEndian.PutUint64(b[0:], i)
		hash := chainhash.HashH(b)

		var tsr *dbnamespace.TreasuryState
		err = testDb.View(func(dbTx database.Tx) error {
			tsr, err = DbFetchTreasury(dbTx, hash)
			return err
		})
		if err != nil {
			t.Fatalf("%v", err.Error())
		}

		if !reflect.DeepEqual(ts, *tsr) {
			t.Fatalf("not same treasury state got %v wanted %v",
				spew.Sdump(ts), spew.Sdump(*tsr))
		}
	}
}
